'use strict';

var path = require('path');

module.exports = function(verb) {
  verb.use(require('verb-generate-readme'));
  verb.generator('project', require('./'));

  verb.create('trees', {viewType: ['partial']});
  verb.helper('toList', function(tree) {
    var defaultTask = tree.getItem('default.txt');
    var lines = toFilenames(defaultTask.content);

    var str = '';
    tree.items.forEach(function(item) {
      str += '\n### ' + item.stem;
      str += '\n';
      str += `Files generated by the [${item.stem} task](#${item.stem}-1):`;
      str += '\n```diff\n';
      str += diff(defaultTask, lines, item.content);
      str += '\n```\n';
    });
    return str;
  });

  function diff(defaultTask, lines, content) {
    var orig = content.split('\n');
    var arr = toFilenames(content);
    var temp = arr.slice();
    var len = arr.length;
    var idx = -1;

    while (++idx < len) {
      var filename = arr[idx];
      if (!filename.trim()) continue;
      if (lines.indexOf(filename) === -1) {
        arr[idx] = '+' + orig[idx];
      } else {
        arr[idx] = ' ' + orig[idx];
      }
    }

    var origDefault = defaultTask.content.split('\n');
    for (var i = 0; i < lines.length; i++) {
      var line = lines[i];
      if (temp.indexOf(line) === -1) {
        arr.splice(i, 0, '-' + origDefault[i]);
      }
    }

    return arr.join('\n');
  }

  function hasFile(arr, name) {
    return arr.indexOf(name) === -1;
  }

  function toFilenames(str) {
    return str.split('\n').map(function(line) {
      return sanitize(line);
    });
  }

  function sanitize(str) {
    if (str === '.' || !str || /^\s+$/.test(str)) return str;
    var m = /[-.\w_]+/g.exec(str);
    return m ? m[0] : str;
  }

  verb.helper('fileList', function(name) {
    var project = this.app.getGenerator('project');
    var deps = this.app.pkg.get('dependencies');
    var list = '';

    project.tasks[name || 'files'].deps.forEach(function(key) {
      var match = matchDep(deps, key);
      list += `- \`` + key + `\`${match ? `: generated by [${match}][]` : ''}\n`;
    });
    return list;
  });

  verb.task('docs', ['setup', 'templates'], function() {
    verb.trees('docs/trees/*.txt');
    return verb.src('docs/src/*.md')
      .pipe(verb.renderFile('*'))
      .pipe(verb.dest('docs'));
  });

  /**
   * Load `tree` partials
   */

  verb.task('trees', function(cb) {
    verb.trees('docs/trees/*.txt');
    cb();
  });

  verb.task('default', ['trees', 'readme']);
};

function matchDep(deps, key) {
  var keys = Object.keys(deps);
  var len = keys.length;
  var idx = -1;
  while (++idx < len) {
    var dep = keys[idx];
    var match = /^generate-(.*)/.exec(dep);
    if (!match) continue;
    var name = match[1];
    if (key.indexOf(name) === 0) {
      return dep;
    }
  }
  return null;
}
