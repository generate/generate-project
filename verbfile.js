'use strict';

module.exports = function(verb) {
  verb.use(require('verb-generate-readme'));
  verb.generator('project', require('./'));
  verb.create('trees', {viewType: ['partial']});

  verb.helper('toList', function(tree) {
    var str = '';
    tree.items.forEach(function(item) {
      str += '\n### ' + item.stem;
      str += '\n';
      str += `Files generated by the [${item.stem} task](#${item.stem}):`;
      str += '\n```\n';
      str += item.content;
      str += '\n```\n';
    });
    return str;
  });

  verb.helper('fileList', function(name) {
    var project = this.app.getGenerator('project');
    var deps = this.app.pkg.get('dependencies');
    var list = '';

    project.tasks[name || 'files'].deps.forEach(function(key) {
      var match = matchDep(deps, key);
      list += `- \`` + key + `\`${match ? `: generated by [${match}][]` : ''}\n`;
    });
    return list;
  });

  verb.task('docs', ['setup', 'templates'], function() {
    verb.trees('docs/trees/*.txt');
    return verb.src('docs/src/*.md')
      .pipe(verb.renderFile('*'))
      .pipe(verb.dest('docs'));
  });

  verb.task('trees', function(cb) {
    verb.trees('docs/trees/*.txt');
    cb();
  });

  verb.task('default', ['trees', 'readme']);
};

function matchDep(deps, key) {
  var keys = Object.keys(deps);
  var len = keys.length;
  var idx = -1;
  while (++idx < len) {
    var dep = keys[idx];
    var match = /^generate-(.*)/.exec(dep);
    if (!match) continue;
    var name = match[1];
    if (key.indexOf(name) === 0) {
      return dep;
    }
  }
  return null;
}
